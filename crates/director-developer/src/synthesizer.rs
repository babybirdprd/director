//! # Context Synthesizer
//!
//! Generates CURRENT_CONTEXT.md from a feature spec.

use crate::reflectors;
use crate::spec;
use anyhow::Result;
use std::fs;
use std::io::Write;
use std::path::Path;

/// Generate CURRENT_CONTEXT.md from a feature spec.
pub fn generate_context(spec_path: &Path, output_path: &Path) -> Result<()> {
    let spec = spec::load_spec(spec_path)?;

    tracing::info!("Generating context for: {}", spec.title);

    // Collect reflection data
    let reflection = reflectors::collect_all()?;

    // Build the markdown content
    let mut content = String::new();

    // Header
    content.push_str(&format!("# CURRENT_CONTEXT: {}\n\n", spec.title));
    content.push_str(&format!(
        "> Auto-generated by director-developer from `{}`\n\n",
        spec_path.display()
    ));

    // User Story
    content.push_str("## User Story\n\n");
    content.push_str(&spec.user_story);
    content.push_str("\n\n");

    // Priority
    content.push_str(&format!("**Priority**: {}\n\n", spec.priority));

    content.push_str("---\n\n");

    // Related Types (JSON Schema)
    if !spec.related_types.is_empty() {
        content.push_str("## Data Contracts (JSON Schema)\n\n");
        content.push_str("The following types are relevant to this feature:\n\n");

        for type_name in &spec.related_types {
            if let Ok(schema) = reflectors::schema::schema_for_type(type_name) {
                content.push_str(&format!("### {}\n\n", type_name));
                content.push_str("```json\n");
                content.push_str(&schema);
                content.push_str("\n```\n\n");
            }
        }
    }

    // Related Functions (Rhai API)
    if !spec.related_functions.is_empty() {
        content.push_str("## Scripting API (Rhai)\n\n");
        content.push_str("The following functions are available:\n\n");

        for pattern in &spec.related_functions {
            if let Ok(functions) = reflectors::scripting::find_functions(pattern) {
                if !functions.is_empty() {
                    content.push_str(&format!("### Functions matching `{}`\n\n", pattern));
                    for func in &functions {
                        content.push_str(&format!("- **{}**", func.name));
                        if !func.params.is_empty() {
                            let params: Vec<String> = func
                                .params
                                .iter()
                                .map(|p| match (&p.name, &p.typ) {
                                    (Some(n), Some(t)) => format!("{}: {}", n, t),
                                    (Some(n), None) => n.clone(),
                                    (None, Some(t)) => t.clone(),
                                    (None, None) => "_".to_string(),
                                })
                                .collect();
                            content.push_str(&format!("({})", params.join(", ")));
                        }
                        if let Some(ret) = &func.return_type {
                            content.push_str(&format!(" -> {}", ret));
                        }
                        content.push('\n');
                        if let Some(doc) = &func.doc_comments {
                            content
                                .push_str(&format!("  - {}\n", doc.lines().next().unwrap_or("")));
                        }
                    }
                    content.push('\n');
                }
            }
        }
    }

    // Pipeline Capabilities
    content.push_str("## Pipeline Capabilities\n\n");
    if let Some(pipeline) = &reflection.pipeline {
        // Node Types
        if let Some(nodes) = pipeline.get("node_types").and_then(|n| n.as_array()) {
            content.push_str("### Available Node Types\n\n");
            content
                .push_str("| Node | Description | Supports Children | Animatable Properties |\n");
            content.push_str("|------|-------------|-------------------|----------------------|\n");
            for node in nodes {
                let name = node.get("name").and_then(|n| n.as_str()).unwrap_or("?");
                let desc = node
                    .get("description")
                    .and_then(|d| d.as_str())
                    .unwrap_or("");
                let children = node
                    .get("supports_children")
                    .and_then(|c| c.as_bool())
                    .map(|b| if b { "✓" } else { "✗" })
                    .unwrap_or("?");
                let props = node
                    .get("animatable_properties")
                    .and_then(|p| p.as_array())
                    .map(|arr| {
                        arr.iter()
                            .filter_map(|v| v.as_str())
                            .collect::<Vec<_>>()
                            .join(", ")
                    })
                    .unwrap_or_default();
                content.push_str(&format!(
                    "| {} | {} | {} | {} |\n",
                    name, desc, children, props
                ));
            }
            content.push('\n');
        }

        // Effects
        if let Some(effects) = pipeline.get("effects").and_then(|e| e.as_array()) {
            content.push_str("### Available Effects\n\n");
            for effect in effects {
                let name = effect.get("name").and_then(|n| n.as_str()).unwrap_or("?");
                let desc = effect
                    .get("description")
                    .and_then(|d| d.as_str())
                    .unwrap_or("");
                let params = effect
                    .get("params")
                    .and_then(|p| p.as_array())
                    .map(|arr| {
                        arr.iter()
                            .filter_map(|v| v.as_str())
                            .collect::<Vec<_>>()
                            .join(", ")
                    })
                    .unwrap_or_default();
                content.push_str(&format!("- **{}**: {} ({})\n", name, desc, params));
            }
            content.push('\n');
        }

        // Constraints
        if let Some(constraints) = pipeline.get("constraints") {
            content.push_str("### System Constraints\n\n");
            content.push_str("```json\n");
            content.push_str(&serde_json::to_string_pretty(constraints)?);
            content.push_str("\n```\n\n");
        }
    }

    // Proposed Changes
    if !spec.schema_changes.is_empty()
        || !spec.scripting_requirements.is_empty()
        || !spec.pipeline_requirements.is_empty()
    {
        content.push_str("---\n\n");
        content.push_str("## Proposed Changes\n\n");

        if !spec.schema_changes.is_empty() {
            content.push_str("### Schema Layer\n\n");
            for change in &spec.schema_changes {
                content.push_str(&format!("- **{}**: {:?}\n", change.target, change.change));
            }
            content.push('\n');
        }

        if !spec.scripting_requirements.is_empty() {
            content.push_str("### Scripting Layer\n\n");
            for req in &spec.scripting_requirements {
                content.push_str(&format!("- `{}`: `{}`\n", req.function_name, req.signature));
                if let Some(doc) = &req.doc_comment {
                    content.push_str(&format!("  - {}\n", doc));
                }
            }
            content.push('\n');
        }

        if !spec.pipeline_requirements.is_empty() {
            content.push_str("### Pipeline Layer\n\n");
            for req in &spec.pipeline_requirements {
                content.push_str(&format!("- {}\n", req.description));
                if let Some(area) = &req.affected_area {
                    content.push_str(&format!("  - Affects: `{}`\n", area));
                }
            }
            content.push('\n');
        }
    }

    // Verification
    content.push_str("---\n\n");
    content.push_str("## Verification Plan\n\n");
    if spec.verification.script_compiles {
        content.push_str("- [ ] Rhai scripts compile without errors\n");
    }
    if spec.verification.schema_validates {
        content.push_str("- [ ] JSON payloads validate against schema\n");
    }
    for script in &spec.verification.custom_scripts {
        content.push_str(&format!("- [ ] Custom: `{}`\n", script));
    }
    for test in &spec.verification.test_cases {
        content.push_str(&format!("- [ ] Test: {}\n", test));
    }

    // Write the file
    if let Some(parent) = output_path.parent() {
        fs::create_dir_all(parent)?;
    }
    let mut file = fs::File::create(output_path)?;
    file.write_all(content.as_bytes())?;

    tracing::info!(
        "Generated {} ({} bytes)",
        output_path.display(),
        content.len()
    );

    Ok(())
}
